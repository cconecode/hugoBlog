<!doctype html>
<html lang="zh-CN">
<head>
    
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.60.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>CSS学习(七)：Grid布局 | 悉达多｜PainMaker</title>
    <meta property="og:title" content="CSS学习(七)：Grid布局 - 悉达多｜PainMaker">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2020-07-01T13:31:41&#43;08:00">
        
        
    <meta property="article:modified_time" content="2020-07-01T13:31:41&#43;08:00">
        
    <meta name="Keywords" content="">
    <meta name="description" content="CSS学习(七)：Grid布局">
        
    <meta name="author" content="悉达多">
    <meta property="og:url" content="https://superchun.net/post/css-study-gridlayout/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-153875253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-153875253-1');
    </script>
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.0/styles/monokai-sublime.min.css">
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.0/highlight.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.0/languages/dart.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                <a id="logo" href="https://superchun.net">
                        悉达多｜PainMaker
                    </a>  
                <p class="description">知也者，所以知也，而不必知</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://superchun.net">首页</a> 
                    <a  href="https://superchun.net/archives/" title="归档">归档</a> 
                    <a  href="https://superchun.net/about/" title="关于">关于</a> 
                </nav>
            </div>
        </div>
    </div>
</header>

<div id="body">
        
        
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">CSS学习(七)：Grid布局</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2020年7月1日
                        </date>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        
                        <div class="post-content">
                            <p>相比于 flex 的一维布局（行或列），grid 是一个二维布局系统，也就是说可以同时设置行和列。相比于 CSS 的普通布局，它有着更多的灵活性和更多可能性。</p>
<h2 id="heading">基本术语及属性</h2>
<h3 id="grid-">Grid 容器</h3>
<p>当一个元素的 <code>display</code>设为<code>grid</code>时，它是一个 grid 容器。</p>
<h3 id="grid-item">Grid item</h3>
<p>grid 容器的直接子元素称为 grid item。</p>
<h3 id="grid-line">Grid line</h3>
<p>grid line 是组成网格结构的分隔线，它们可以为垂直的（列网格线）或水平的（行网格线），并且位于行或列的任一侧。grid line 主要作用在于定位每一个网格元素，grid 会为每条 grid line 创建编号，其顺序取决于书写模式，从 1 开始。</p>
<h3 id="grid-cell">Grid cell</h3>
<p>grid cell 是两条相邻的行和两条相邻的列网格线之间的空间，它是 grid 中最小的单元，类似于表格系统中的一个单元格。</p>
<h3 id="grid-track">Grid track</h3>
<p>两条相邻 grid line 之间的空间，可以想象成 gird 中的一行或一列。可以通过<code>grid-template-columns</code>和<code>grid-template-row</code>属性定义网格中的行和列。</p>
<h3 id="grid-area">Grid area</h3>
<p>grid area 是由一个或多个 grid cell 组成的矩形区域，grid area 必须为矩形，不能创建 T 型或 L 型 grid area。</p>
<h3 id="minmax">轨道大小和<code>minmax()</code></h3>
<p>可以使用<code>minmax()</code>作为值来控制轨道的最小尺寸和最大尺寸。例如对<code>grid-auto-rows</code>使用<code>minmax(100px, auto)</code>作为它的值，那么它创建的行的行高会根据内容来自动变换大小，但不会小于 100px。</p>
<h3 id="fr-">fr 单位</h3>
<p>grid 引入了一个新的长度单位<code>fr</code>来创建灵活的网格轨道，<code>fr</code>单位表示网格容器中可用空间的一等份，<code>1fr</code>为一等份，<code>2fr</code>为二等份。</p>
<h3 id="heading1">网格间距</h3>
<p>两个网格单元之间的横向间距和纵向间距可以用<code>grid-column-gap</code>和<code>grid-row-gap</code>来控制，或者直接使用两个合并的缩写<code>grid-gap</code>。</p>
<h3 id="heading2">隐式和显式网格</h3>
<p>显示网格包含了在<code>grid-template-columns</code>和<code>grid-template-rows</code>属性中定义的行和列。当在网格定义之外又放了一些元素，或者因为内容的数量而需要更多网格轨道时，网格会在隐式网格中创建行和列。隐式网格中的轨道会自动定义尺寸，也可以用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>属性来定义一个设置大小的轨道。</p>
<h3 id="zindex">z-index</h3>
<p>当网格中的元素有重叠时，可以使用<code>z-index</code>来控制显示的顺序，<code>z-index</code>的值越大，会显示在越上方。</p>
<h2 id="grid-1">Grid 布局特点</h2>
<p>grid 布局有以下特点：</p>
<ul>
<li><strong>固定的位置和弹性的轨道大小</strong>。轨道的大小可以使用固定的值，例如 px，也可以使用百分比或专门的<code>fr</code>单位来创建灵活的弹性轨道。</li>
<li><strong>元素位置</strong>。可以使用行号、行名或者标定一个 grid area 来精确定位元素，grid 同时还有一种算法来控制未给出明确网格位置的元素。</li>
<li><strong>创建额外的轨道来包含元素</strong>。可以使用 grid 布局来定义一个显式网格，但是根据规范，加在网格外面的内容也会被处理，必要时会自动增加行和列，尽可能多的容纳所有的列。</li>
<li><strong>对齐控制</strong>。可以控制放在 grid 内元素的对齐，也可以控制整个 grid 如何对齐。</li>
<li><strong>控制重叠内容</strong>。当多个元素之间彼此重叠时，可以使用<code>z-index</code>属性控制重叠区域的显示优先级。</li>
</ul>
<h2 id="grid-2">Grid 网格线定位详解</h2>
<p>grid 使用基于网格线的定位控制元素在网格上的位置。使用 grid 布局时，会给网格线编号，分为行和列，从 1 开始。<code>grid-column-start</code>和<code>grid-column-end</code>控制元素列开始和结束的编号线，<code>grid-row-start</code>和<code>grid-row-end</code>控制元素的行开始和结束编号线。也可以使用它们的缩写形式：<code>grid-column</code>和<code>grid-row</code>，<code>grid-column</code>和<code>grid-row</code>都以<code>start / end</code>的形式设置开始和结束编号线。例如：<code>grid-row: 1 / 4;</code>表示元素从第一行线开始，延伸到第四行线。</p>
<h3 id="heading3">默认跨度</h3>
<p>如果元素只跨越一个轨道的话，则可以省略<code>grid-column-end</code>或<code>grid-row-end</code>的值。</p>
<h3 id="gridared-">grid-ared 属性</h3>
<p><code>grid-area</code>属性是行开始结束和列开始结束的集合，值的顺序如下：</p>
<ul>
<li>grid-row-start</li>
<li>grid-column-start</li>
<li>grid-row-end</li>
<li>grid-column-end</li>
</ul>
<p>也就是用一个属性确定一个元素的定位</p>
<h3 id="heading4">反方向计数</h3>
<p>也可以从行和列结束线开始反方向计数，对于从左至右的书写模式而言，就是最右端的列线和最底端的行线。它们会被记为 -1，然后开始向前数，倒数第二条线被记为 -2。</p>
<p>最后一条线是指显式定义网格中的最后一条线，即由<code>grid-template-rows</code>和<code>grid-template-columns</code>所定义的网格，并不会把隐式网格加入的行和列计入其中。</p>
<h3 id="span"><code>span</code>关键字</h3>
<p><code>span</code>关键字主要用于“起始线与跨越轨道数量”的定位方法，它与上面的“起始线与结束线”的定位方法不同。<code>span</code>可以用在<code>grid-row-start`/</code>grid-row-end<code>和</code>grid-column-start<code>/</code>grid-column-end<code>属性中。例如：设置</code>grid-row:1 / span 3<code>，则表示这个元素从 1 号线开始，跨越 3 个轨道到 4 号线结束；或者设置</code>grid-row: span 3 / 4`，则表示元素会从 4 号线开始，往前跨越 3 个轨道到 1 号线。</p>
<h2 id="heading5">网格模板区域</h2>
<p>除了使用基于网格线的定位方式，还可以使用对模板区域命名的方式来定位元素。</p>
<p>使用模板区域命名主要分为两步：</p>
<ol>
<li>
<p>用<code>grid-area</code>对网格元素进行命名，如：<code>grid-area:header</code></p>
</li>
<li>
<p>在网格容器中对<code>grid-template-areas</code>使用网格元素的命名进行完整的布局：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">header</span> {
 <span style="color:#66d9ef">grid-area</span>: hd;
}
.<span style="color:#a6e22e">footer</span> {
 <span style="color:#66d9ef">grid-area</span>: ft;
}
.<span style="color:#a6e22e">content</span> {
     <span style="color:#66d9ef">grid-area</span>: main;
}
.<span style="color:#a6e22e">grid-container</span> {
     <span style="color:#66d9ef">grid-template-areas</span>:
      <span style="color:#e6db74">&#34;hd hd hd hd hd hd hd&#34;</span>
      <span style="color:#e6db74">&#34;main main main ft ft ft ft&#34;</span>
}
</code></pre></div></li>
</ol>
<p><code>grid-template-areas</code>的值必须是一个完整的布局，否则会无效。即每一行都应该有相同的单元格，如果网格不是矩形也是无效的。</p>
<h3 id="heading6">留出空白的网格单元</h3>
<p>如果要在网格中留出空白，则在布局中使用&quot;<code>.</code>&rdquo;，<code>.</code>之间没有空格的话会被记为一个单元格。</p>
<h2 id="heading7">对网格线进行命名定位</h2>
<p>在使用<code>grid-template-columns</code>和<code>grid-template-rows</code>定义网格时，可以对网格线进行全部或部分命名，后续可以使用这些命名线进行定位。</p>
<p>对网格线命名，只需要在定义的时候，把网格线的名字写在方括号内，名字随意：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">grid-container</span> {
	<span style="color:#66d9ef">grid-template-rows</span>: [main-start] <span style="color:#ae81ff">1</span>fr [main-end] <span style="color:#ae81ff">1</span>fr;
  <span style="color:#66d9ef">grid-template-columns</span>: [main-start] <span style="color:#ae81ff">100</span><span style="color:#66d9ef">px</span> [main-end] <span style="color:#ae81ff">100</span><span style="color:#66d9ef">px</span>;
}
</code></pre></div><p>一旦对网格线进行了命名，就可以使用比序号更方便易用的方式进行定位了。只需要把需要换成对应的命名网格线，更容易理解与记忆。</p>
<p>除此之外，还可以对同一根网格线进行多个命名，只需要把多个名字写进方括号内，用空格隔开。在引用时，可以使用任一名字。</p>
<h3 id="heading8">由网格区域隐式定义的命名线</h3>
<p>如果对网格区域进行了命名，那么就会隐式地创建对应的命名线。如：使用<code>grid-area</code>属性创建命名的区域，然后用<code>grid-template-areas</code>创建布局，区域的名字为：<code>hd</code>、<code>ft</code>、<code>main</code>。那么，就会隐式地创建了如下命名线：<code>hd-start</code>、<code>hd-end</code>、<code>ft-start</code>、<code>ft-end</code>、<code>main-start</code>、<code>main-end</code>。可以使用这些隐式的命名线来定位其它元素，和显示地命名网格线是一样的。</p>
<h3 id="-repeat-">用 repeat() 定义相同名字的多条线</h3>
<p>使用<code>repeat</code>语法，可以创建多条具有相同名字的网格线，这种方法在某些情况下是有用的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">grid-container</span> {
	<span style="color:#66d9ef">grid-template-columns</span>: <span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">12</span>, <span style="color:#960050;background-color:#1e0010">[</span>col<span style="color:#f92672">-</span><span style="color:#66d9ef">start</span><span style="color:#960050;background-color:#1e0010">]</span> <span style="color:#ae81ff">1</span>fr);
}
</code></pre></div><p>上面的写法会创建一个有 12 等宽列的网格，每一列左侧的网格线命名为<code>col-start</code>。对于有多条相同名字的网格线，其名字是指第一条线，即上面的<code>col-start</code>是指左侧的第一条线。如果要引用其他同名的网格线，则要在其名字后面加上序号，如：<code>col-start 5</code>，是指第 5 条网格线。</p>
<h2 id="heading9">网格布局中的自动定位</h2>
<p>网格布局中还有另外一组规则，那就是如果没有为网格项目指定定位信息，它们会把自己放在网格中，每个单元格中放一个。</p>
<h3 id="heading10">自动定位的默认规则</h3>
<p>网格中默认的流向是按行排列项目，网格会首先在第 1 行的每个单元格中放置项目。如果已经通过<code>grid-template-rows</code>属性创建了其他行，网格就会继续把项目放到这些行中。如果没有足够的行来放置所有项目，那么就会创建新的隐式行。</p>
<h4 id="heading11">调整隐式行的大小</h4>
<p>在默认情况下，被自动创建出来的隐式行的尺寸是自适应的，也就是会根据内容自动变换大小，而不会让内容溢出。通过<code>grid-auto-rows</code>属性可以控制隐式行的大小，也可以使用<code>minmax()</code>设置最大最小尺寸。</p>
<h4 id="heading12">按列自动定位</h4>
<p>可以通过<code>grid-auto-flow</code>属性改变网格的默认流向，将其设为<code>column</code>，就可以按列来自动定位项目。同样地，被自动创建出来的隐式列也是自适应大小的，可以通过<code>grid-auto-columns</code>控制隐式列的大小。</p>
<h2 id="heading13">网格中的对齐</h2>
<p>不同于 flexbox，grid 中有两条轴用于对齐——块方向的列轴和文本方向的行轴。</p>
<h3 id="heading14">项目在块方向列轴上的对齐</h3>
<p><code>align-slef</code>和<code>align-items</code>用于控制项目在块方向上的列轴。<code>align-items</code>用于 grid 容器中，如果 grid 容器设置了这个属性，那么所有项目都会采用这个对齐方式。<code>align-self</code>则用于控制单个项目的对齐。</p>
<p>它们的值都可以设置为：</p>
<ul>
<li>auto</li>
<li>normal</li>
<li>start</li>
<li>end</li>
<li>center</li>
<li>stretch</li>
<li>baseline</li>
<li>first baseline</li>
<li>last baseline</li>
</ul>
<p><code>align-self</code>的默认值为<code>stretch</code>，如果项目具有固定宽高比，它的值就会变为<code>start</code>。因为如果将一个具有固定宽高比的项目进行拉伸，将会导致它变形。</p>
<h3 id="heading15">项目在文本方向行轴上的对齐</h3>
<p>同<code>align-self</code>和<code>align-items</code>一样，<code>justify-self</code>和<code>justify-items</code>用于项目在文本方向上的对齐。它们的值也有：</p>
<ul>
<li>auto</li>
<li>normal</li>
<li>start</li>
<li>end</li>
<li>center</li>
<li>stretch</li>
<li>baseline</li>
<li>first baseline</li>
<li>last baseline</li>
</ul>
<p>同样地，默认对齐方式也是<code>stretch</code>，除非项目具有宽高比。也就是说，在默认情况下，网格项目会覆盖整个网格区域，除非改变它们的对齐方式。</p>
<h3 id="heading16">项目轨道在块方向和文本方向上的对齐</h3>
<p>如果网格轨道整体所占据的空间小于网格容器，那么就可以设置网格轨道在容器中的对齐。同项目一样，它们也有两个方向的对齐：块方向和文本方向。分别使用<code>align-content</code>属性设置块方向的对齐，使用<code>justify-content</code>属性设置文本方向的对齐。它们的可选值都是：</p>
<ul>
<li>normal</li>
<li>start</li>
<li>end</li>
<li>center</li>
<li>stretch</li>
<li>space-around</li>
<li>space-between</li>
<li>space-evenly</li>
<li>baseline</li>
<li>first baseline</li>
<li>last baseline</li>
</ul>
<p><code>align-content</code>属性的默认值为<code>start</code>，即网格轨道整体居于网格的左上角，紧挨着网格的起始线。将其设为<code>end</code>，则会紧靠着网格的最后一条线。</p>
<p>与 flex 布局类似，<code>space-between</code>、<code>space-between</code>和<code>space-evenly</code>值也用于分配空间的值。不同的是，如果网格中的项目跨越了多于一条轨道，这些值会使得项目变大。因为网格的间隙变大了，所以项目也变得更大了。</p>

                        </div>

                        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://superchun.net">悉达多</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://superchun.net/post/css-study-gridlayout/">https://superchun.net/post/css-study-gridlayout/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/css-study-flexbox/">CSS学习(六)：Flex布局</a></li>
        
        <li><a href="/post/css-study-visiual-style/">CSS学习(五)：视觉格式化模型</a></li>
        
        <li><a href="/post/css-study-box/">CSS学习(四)：盒子模型</a></li>
        
        <li><a href="/post/css-study-cascade-priority/">CSS学习(三)：CSS层叠与优先级</a></li>
        
        <li><a href="/post/css-study-childselector/">CSS学习(二)：兄弟和子选择器</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://superchun.net/tags/Web">Web</a></li>
                                
                                <li><a href="https://superchun.net/tags/CSS">CSS</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "superchun/blogcomment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="/search/" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://superchun.net">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://superchun.net/post/css-study-gridlayout/" title="CSS学习(七)：Grid布局">CSS学习(七)：Grid布局</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-flexbox/" title="CSS学习(六)：Flex布局">CSS学习(六)：Flex布局</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-visiual-style/" title="CSS学习(五)：视觉格式化模型">CSS学习(五)：视觉格式化模型</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-box/" title="CSS学习(四)：盒子模型">CSS学习(四)：盒子模型</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-cascade-priority/" title="CSS学习(三)：CSS层叠与优先级">CSS学习(三)：CSS层叠与优先级</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-childselector/" title="CSS学习(二)：兄弟和子选择器">CSS学习(二)：兄弟和子选择器</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/css-study-arrtibuteselector/" title="CSS学习(一)：属性选择器">CSS学习(一)：属性选择器</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/lexical_scope/" title="Lexical Scope">Lexical Scope</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/github-access-changesource/" title="关于Github访问慢及修改源的那些事">关于Github访问慢及修改源的那些事</a>
    </li>
    
    <li>
        <a href="https://superchun.net/post/sort-algorithm-heapsort-mergesort/" title="从Heapsort与Mergesort看排序算法">从Heapsort与Mergesort看排序算法</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://superchun.net/tags/CSS/">CSS</a>
    
    <a href="https://superchun.net/tags/Cordova/">Cordova</a>
    
    <a href="https://superchun.net/tags/JS/">JS</a>
    
    <a href="https://superchun.net/tags/OpenGL-ES/">OpenGL ES</a>
    
    <a href="https://superchun.net/tags/Web/">Web</a>
    
    <a href="https://superchun.net/tags/git-ssh/">git ssh</a>
    
    <a href="https://superchun.net/tags/iOS/">iOS</a>
    
    <a href="https://superchun.net/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/">事件拦截</a>
    
    <a href="https://superchun.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://superchun.net/tags/%E6%9D%82%E8%B0%88%E4%BD%8E%E8%AF%AD/">杂谈低语</a>
    
    <a href="https://superchun.net/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://superchun.net/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://superchun.net">悉达多｜PainMaker By 悉达多</a>. Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>. 
    </div>
</footer>


<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.13.0/flowchart.min.js" crossorigin="anonymous"></script>
<script>
    {
        {
            -
            if .Params.flowchartDiagrams.options -
        }
    }
    window.flowchartDiagramsOptions = {
        {.Params.flowchartDiagrams.options | safeJS
        }
    }; {
        {
            -
            else if .Site.Params.flowchartDiagrams.options -
        }
    }
    window.flowchartDiagramsOptions = {
        {.Site.Params.flowchartDiagrams.options | safeJS
        }
    }; {
        {
            -end -
        }
    }
    (function() {
        if (!window.flowchart) return;
        const blocks = document.querySelectorAll('pre code.language-flowchart, pre code.language-flow');
        for (let i = 0; i < blocks.length; i++) {
            const block = blocks[i];
            const rootElement = block.parentNode;
            const container = document.createElement('div');
            const id = `js-flowchart-diagrams-${i}`;
            container.id = id;
            container.className = 'align-center';
            container.setAttribute("style", "overFlow-x:auto");
            rootElement.parentNode.replaceChild(container, rootElement);
            const diagram = flowchart.parse(block.childNodes[0].nodeValue);
            diagram.drawSVG(id, window.flowchartDiagramsOptions ? window.flowchartDiagramsOptions : {});
        }
    })();
</script>
<script type="text/javascript">
    
    (function() {
        $("pre code").parent().addClass("line-numbers")
    }());

    window.MathJax = {
        tex2jax: {
            inlineMath: [
                ['$', '$']
            ],
            processEscapes: true
        }
    };
</script>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-153875253-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
 
<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




<script type="text/javascript">
(function(){
	if (typeof self === 'undefined' || !self.Prism || !self.document) {
		return;
	}

	if (!Prism.plugins.toolbar) {
		console.warn('Copy to Clipboard plugin loaded before Toolbar plugin.');

		return;
	}

	var ClipboardJS = window.ClipboardJS || undefined;

	if (!ClipboardJS && typeof require === 'function') {
		ClipboardJS = require('clipboard');
	}

	var callbacks = [];

	if (!ClipboardJS) {
		var script = document.createElement('script');
		var head = document.querySelector('head');

		script.onload = function() {
			ClipboardJS = window.ClipboardJS;

			if (ClipboardJS) {
				while (callbacks.length) {
					callbacks.pop()();
				}
			}
		};

		script.src = 'https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js';
		head.appendChild(script);
	}

	Prism.plugins.toolbar.registerButton('copy-to-clipboard', function (env) {
		var linkCopy = document.createElement('button');
		linkCopy.textContent = '复制代码';

		if (!ClipboardJS) {
			callbacks.push(registerClipboard);
		} else {
			registerClipboard();
		}

		return linkCopy;

		function registerClipboard() {
			var clip = new ClipboardJS(linkCopy, {
				'text': function () {
					return env.code;
				}
			});

			clip.on('success', function() {
				linkCopy.textContent = '复制成功!';

				resetText();
			});
			clip.on('error', function () {
				linkCopy.textContent = '按 Ctrl+C 复制';

				resetText();
			});
		}

		function resetText() {
			setTimeout(function () {
				linkCopy.textContent = '复制代码';
			}, 5000);
		}
	});
})();

</script>
</body>
</html>
