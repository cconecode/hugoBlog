<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>悉达多｜PainMaker  | iOS 事件拦截</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.60.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="iOS 事件拦截" />
<meta property="og:description" content="在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://superchun.net/post/iOS-event/" />

<meta itemprop="name" content="iOS 事件拦截">
<meta itemprop="description" content="在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。">

<meta itemprop="wordCount" content="1563">



<meta itemprop="keywords" content="事件拦截," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 事件拦截"/>
<meta name="twitter:description" content="在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://superchun.net" class="f3 fw2 hover-white no-underline white-90 dib">
      悉达多｜PainMaker
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/archives/" title="归档 page">
              归档
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="关于 page">
              关于
            </a>
          </li>
          
        </ul>
      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        
      </p>
      <h1 class="f1 athelas mb1">iOS 事件拦截</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。</p>
<h1 id="ios">iOS事件机制</h1>
<p>iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html">官方文档</a>），我们遇到情况是第一种也就是触摸事件的机制。</p>
<h2 id="heading">响应者链</h2>
<p>当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。</p>
<p>iOS 中的响应者链：
<img src="https://lh3.googleusercontent.com/-6DVPdEbo12A/V48oTEjGXfI/AAAAAAAAAAk/Vn_s04cJOlk/I/14689996896970.jpg" alt="苹果官方关于响应者链的描述"></p>
<p>从图中我们可以观察到，响应者链有以下几个特点：</p>
<ul>
<li>
<p>响应者链通常由 initial view 开始。</p>
</li>
<li>
<p>View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。</p>
</li>
<li>
<p>ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。</p>
</li>
<li>
<p>Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。</p>
</li>
</ul>
<p>由于 UI 的复杂性，整个响应者链是需要通过计算的，而计算顺序基本是与响应者链分发相反的。<code>无论哪种事件，都是系统本身先获得，再交给 UIApplication，由 UIApplication 决定交给谁去处理。</code> 关于事件分发的计算网上有很多文章，我就不赘述了。通过上述了解，我们可以得出一个结论：<code>如果我们需要拦截一个事件，最好的机会是在 UIApplication 里面。</code></p>
<h1 id="heading1">需求具体实现</h1>
<h2 id="oc-">OC 版</h2>
<p>根据上面的结论，我们目前的思路是继承 UIApplication，然后实现某一方法，进行事件拦截。根据查阅资料，重写 UIApplication 的 <code>sendEvent</code>方法可以达到目的，sendEvent介绍如下：</p>
<blockquote>
<p><strong>sendEvent:</strong></p>
</blockquote>
<blockquote>
<p>Dispatches an event to the appropriate responder objects in the application.</p>
</blockquote>
<blockquote>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">-(<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sendEvent:</span>(UIEvent <span style="color:#f92672">*</span>)event
</code></pre></div><blockquote>
<p><strong>Parameters</strong>
event
A UIEvent object encapsulating the information about an event, including the touches involved.</p>
</blockquote>
<blockquote>
<p><strong>Discussion</strong>
Subclasses may override this method to intercept incoming events for inspection and special dispatching. iOS calls this method for public events only.</p>
</blockquote>
<p>具体代码实现：</p>
<ol>
<li>新建一个继承 UIApplication 的 CTApplication，重写 sendEvent 方法，并判断是否为触摸事件：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;CTApplication.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">CTApplication</span>

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sendEvent:</span>(UIEvent <span style="color:#f92672">*</span>)event {

    <span style="color:#66d9ef">if</span> (event.type <span style="color:#f92672">=</span><span style="color:#f92672">=</span> UIEventTypeTouches) {
        <span style="color:#66d9ef">if</span> ([[event.allTouches anyObject] phase] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> UITouchPhaseBegan) {

        }
    }
 [super sendEvent:event];
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>2.由于需要检测用户多长时间没有点击屏幕，需要加一个定时器来进行倒计时，设置定时器的方法写在 CTApplication 的 init 方法中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;CTApplication.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/** 不点击屏幕的时间 */</span>
<span style="color:#66d9ef">static</span> NSTimeInterval <span style="color:#66d9ef">const</span> showTime <span style="color:#f92672">=</span> <span style="color:#ae81ff">180</span>;

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">CTApplication</span> ()

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) NSTimer <span style="color:#f92672">*</span>timer;

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">CTApplication</span>

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {

    <span style="color:#66d9ef">if</span> (self <span style="color:#f92672">=</span><span style="color:#f92672">=</span> [super init]) {
        [self setTimer];
    }
    <span style="color:#66d9ef">return</span> self;
}
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setTimer</span> {

    self.timer <span style="color:#f92672">=</span> [NSTimer timerWithTimeInterval:showTime target:self selector:<span style="color:#66d9ef">@selector</span>(showPicture) userInfo:nil repeats:NO];
    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">showPicture</span> {
	<span style="color:#75715e">/** 在这里对广告轮播图进行设置 */</span>
}
</code></pre></div><p>3.再回到 sendEvent 方法中，如果该方法被触发了，那么让定时器失效，重新开始定时：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sendEvent:</span>(UIEvent <span style="color:#f92672">*</span>)event {
    
    [super sendEvent:event];
    <span style="color:#66d9ef">if</span> (event.type <span style="color:#f92672">=</span><span style="color:#f92672">=</span> UIEventTypeTouches) {
        <span style="color:#66d9ef">if</span> ([[event.allTouches anyObject] phase] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> UITouchPhaseBegan) {

            [self.timer invalidate];
            [self setTimer];
        }
    }
}
</code></pre></div><p>4.最后，在 main 函数中还要做对应的更改，替换 UIApplication 的调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;UIKit</span><span style="color:#75715e">/</span><span style="color:#75715e">UIKit.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;AppDelegate.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;CTApplication.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
<span style="color:#75715e">//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> UIApplicationMain(argc, argv, NSStringFromClass([AppDelegate <span style="color:#66d9ef">class</span>]), NSStringFromClass([CTApplication <span style="color:#66d9ef">class</span>]));
    }
}
</code></pre></div><h2 id="swift">Swift版</h2>
<p>首先新建一个 UIApplication 的子类 CTApplication：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Swift" data-lang="Swift"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Foundation</span>
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">UIKit</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CTApplication</span>: UIApplication {

    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendEvent</span>(event: UIEvent) {

        <span style="color:#66d9ef">super</span>.sendEvent(event)
    }
}
</code></pre></div><p>由于 Swift 中没有 main 函数，所以需要自己手动建一个 main 函数，并设置入口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Swift" data-lang="Swift"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Foundation</span>
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">UIKit</span>

UIApplicationMain(Process.argc, Process.unsafeArgv, NSStringFromClass(CTApplication), NSStringFromClass(AppDelegate))
</code></pre></div><p>这时，Appdelegate 中的<code>@UIApplicationMain</code>会报错。下面是苹果官方对于<code>@UIApplicationMain</code>关键字的描述：</p>
<blockquote>
<p>Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.</p>
</blockquote>
<blockquote>
<p>If you do not use this attribute, supply a main.swift file with a main function that calls the UIApplicationMain(::<em>:) function. For example, if your app uses a custom subclass of UIApplication
as its principal class, call the UIApplicationMain(::</em>:) function instead of using this attribute.</p>
</blockquote>
<p>意思就是在类的最顶部声明 <code>@UIApplicationMain</code>，表示该类是Application 的 delegate，另外一种做法就是在 main.Swift 中调用 UIApplicationMain 函数，设置 delegate 和 application。而我们采取的是后面的办法，所以 delegate 冲突了，自然就会报错，只要把 Appdelegate 上的 <code>@UIApplicationMain</code> 关键字删除就可以了。剩下的操作与 OC 中的是一样的。</p>
<p>具体的代码上传到 github 上了：</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">事件拦截</a>
   </li>
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://superchun.net" >
    &copy; 2021 悉达多｜PainMaker
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
