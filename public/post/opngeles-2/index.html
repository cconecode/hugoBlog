<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>悉达多｜PainMaker  | OpenGL实战(一) - 简单图形绘制</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.60.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="OpenGL实战(一) - 简单图形绘制" />
<meta property="og:description" content="在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码&#43;知识点&#43;API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://superchun.net/post/opngeles-2/" />

<meta itemprop="name" content="OpenGL实战(一) - 简单图形绘制">
<meta itemprop="description" content="在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码&#43;知识点&#43;API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我">

<meta itemprop="wordCount" content="2426">



<meta itemprop="keywords" content="OpenGL ES," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="OpenGL实战(一) - 简单图形绘制"/>
<meta name="twitter:description" content="在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码&#43;知识点&#43;API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://superchun.net" class="f3 fw2 hover-white no-underline white-90 dib">
      悉达多｜PainMaker
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/archives/" title="归档 page">
              归档
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="关于 page">
              关于
            </a>
          </li>
          
        </ul>
      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        
      </p>
      <h1 class="f1 athelas mb1">OpenGL实战(一) - 简单图形绘制</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>在<a href="http://parisdog.club/OpenGLES-1.html">上一篇文章中</a>我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我</p>
<h1 id="heading">渲染屏幕====</h1>
<p>首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">// 直接把上篇文章的初始化方法copy过来
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 创建一个上下文，并设置为当前上下文
</span><span style="color:#75715e"></span>EAGLContext <span style="color:#f92672">*</span>context <span style="color:#f92672">=</span> [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
[EAGLContext setCurrentContext:context];
    
<span style="color:#75715e">//    使用代码初始化
</span><span style="color:#75715e"></span><span style="color:#75715e">//    GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context
</span><span style="color:#75715e"></span>    
<span style="color:#75715e">//    使用Storyboard初始化
</span><span style="color:#75715e"></span>GLKView <span style="color:#f92672">*</span>view <span style="color:#f92672">=</span> (GLKView <span style="color:#f92672">*</span>)self.view;
view.context <span style="color:#f92672">=</span> context; <span style="color:#75715e">// 关联上下文
</span></code></pre></div><p>只需在GLKView的代理方法<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中，调用<code>glClear</code>的系列函数就可以用OpenGL ES对屏幕进行渲染了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">glkView:</span>(GLKView <span style="color:#f92672">*</span>)view <span style="color:#a6e22e">drawInRect:</span>(CGRect)rect {

    glClearColor(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 清理屏幕的RGB颜色和alpha值，这里我们设置成了红色
</span><span style="color:#75715e"></span>    glClear(GL_COLOR_BUFFER_BIT); <span style="color:#75715e">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区
</span><span style="color:#75715e"></span>}
</code></pre></div><p>现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用<code>draw</code>方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法<code>(void)glkViewControllerUpdate:(GLKViewController *)controller</code>方法来更新屏幕的颜色。</p>
<p>首先定义两个参数并初始化:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) CGFloat redColorFloat; <span style="color:#75715e">// RGB中红色的色值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">getter</span><span style="color:#f92672">=</span>isIncreasing) <span style="color:#66d9ef">BOOL</span> increasing; <span style="color:#75715e">// 判断是否增加
</span><span style="color:#75715e"></span>
self.increasing <span style="color:#f92672">=</span> YES;
self.redColorFloat <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</code></pre></div><p>设定GLKViewController的刷新频率:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">self.preferredFramesPerSecond <span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>;
</code></pre></div><p>更新<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中的代码，在GLKViewController的代理方法中更新屏幕颜色:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">glkView:</span>(GLKView <span style="color:#f92672">*</span>)view <span style="color:#a6e22e">drawInRect:</span>(CGRect)rect {

    glClearColor(self.redColorFloat, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 清理屏幕的RGB颜色和alpha值
</span><span style="color:#75715e"></span>    glClear(GL_COLOR_BUFFER_BIT); <span style="color:#75715e">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区
</span><span style="color:#75715e"></span>}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">glkViewControllerUpdate:</span>(GLKViewController <span style="color:#f92672">*</span>)controller {
    
    <span style="color:#66d9ef">if</span> (self.isIncreasing) {
        self.redColorFloat <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">*</span> self.timeSinceLastUpdate;
    }<span style="color:#66d9ef">else</span> {
        self.redColorFloat <span style="color:#f92672">-</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">*</span> self.timeSinceLastUpdate;
    }
    
    <span style="color:#66d9ef">if</span> (self.redColorFloat <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>) {
        self.redColorFloat <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
        self.increasing <span style="color:#f92672">=</span> NO;
    }
    
    <span style="color:#66d9ef">if</span> (self.redColorFloat <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        self.redColorFloat <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        self.increasing <span style="color:#f92672">=</span> YES;
    }
}
</code></pre></div><p>这样就实现了屏幕黑红闪烁效果，Demo可以在<a href="https://github.com/cconecode/OpenGLESTutorials/tree/master/Tutorial1-ScreenRendering">这里</a>找到。</p>
<h1 id="heading1">绘制图形</h1>
<p>现在我们来利用OpenGL ES绘制一个正方形。因为OpenGL ES只能渲染三角形，所以要用两个三角形来组成一个正方形。首先创建一组顶点数据和索引数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">// 顶点数据
</span><span style="color:#75715e"></span>    GLfloat verties[] <span style="color:#f92672">=</span> {
        <span style="color:#ae81ff">0.5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.0</span>,  <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>,   <span style="color:#75715e">// 前面为x, y, z, 后面为颜色
</span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0</span>,     <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>,
        <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0</span>,   <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>,
        <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0</span>,    <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>
    };
    
    <span style="color:#75715e">// 索引数据
</span><span style="color:#75715e"></span>    GLuint indecs[] <span style="color:#f92672">=</span> {
        <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>,
        <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>
    };
</code></pre></div><p>顶点数据中包括了顶点位置和对应的颜色，索引数据则是顶点数组的索引。然后我们需要向OpenGL ES发送数据和缓存数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">    glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>vertBuffer); <span style="color:#75715e">// 创建缓冲区对象
</span><span style="color:#75715e"></span>    glBindBuffer(GL_ARRAY_BUFFER, vertBuffer); <span style="color:#75715e">// 指定当前活动缓冲区对象
</span><span style="color:#75715e"></span>                                               <span style="color:#75715e">// GL_ARRAY_BUFFER 坐标，颜色等
</span><span style="color:#75715e"></span>                                               <span style="color:#75715e">// GL_ELEMENT_ARRAY_BUFFER 索引坐标
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">// 把顶点数据从 CPU 复制到 GPU
</span><span style="color:#75715e"></span>    glBufferData(GL_ARRAY_BUFFER, <span style="color:#66d9ef">sizeof</span>(verties), verties, GL_STATIC_DRAW);
    <span style="color:#75715e">// glBufferData(&lt;#GLenum target#&gt;, &lt;#GLsizeiptr size#&gt;, &lt;#const GLvoid *data#&gt;, &lt;#GLenum usage#&gt;)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// target: 可以是GL_ARRAY_BUFFER(顶点数据)，或者GL_ELEMENT_ARRAY_BUFFER(索引数据)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// size: 存储相关数据所需要的内存容量
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// data: 用于初始化缓冲区对象，可以是指向某一块内存地址，也可以是NULL
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//usage: 数据分配后如何读写，详细介绍见：http://parisdog.club/OpenGLES-2.html
</span><span style="color:#75715e"></span>    
    glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>indeBuffer); <span style="color:#75715e">// 索引数据
</span><span style="color:#75715e"></span>    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indeBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span style="color:#66d9ef">sizeof</span>(indecs), indecs, GL_STATIC_DRAW);
</code></pre></div><p>关于 usage 的一些说明：</p>
<ul>
<li>GL_STREAM_DRAW: 数据只指定一次，并且最多只有几次作为绘图和指定图像函数的源数据</li>
<li>GL_STREAM_READ: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次由应用程序作为数据值使用</li>
<li>GL_STREAM_COPY: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次作为绘图和指定图像函数的源数据</li>
<li>GL_STATIC_DRAW: 数据只指定一次，但是可以多次几次作为绘图和指定图像函数的源数据</li>
<li>GL_STATIC_READ:  数据从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用</li>
<li>GL_STATIC_COPY: 数据从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li>
<li>GL_DYNAMIC_DRAW: 数据可以多次指定，并且可以多次几次作为绘图和指定图像函数的源数据</li>
<li>GL_DYNAMIC_READ: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用</li>
<li>GL_DYNAMIC_COPY: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li>
</ul>
<p>在OpenGL ES2.0当中，无论渲染什么图形，都必须用到着色器。着色器是用类C语言-GLSL语言写的，如果想要自定义一个着色器，那么学习这门语言十分有必要。现在<code>GLKBaseEffect</code>这个类为我们提供了一些通用的着色器，在还没有掌握GLSL的情况下，我们目前可以使用它来帮我们实现效果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="color:#75715e">// 定义和初始化一个GLKBaseEffect实例对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) GLKBaseEffect <span style="color:#f92672">*</span>effect;

self.effect <span style="color:#f92672">=</span> [[GLKBaseEffect alloc] init];
<span style="color:#75715e">// 可以设置 effect 的一些属性，配置光，转化等
</span></code></pre></div><p>最后在代理方法中启动着色器:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">glkView:</span>(GLKView <span style="color:#f92672">*</span>)view <span style="color:#a6e22e">drawInRect:</span>(CGRect)rect {

    glClearColor(<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>);
    glClear(GL_COLOR_BUFFER_BIT);
    
    <span style="color:#75715e">// 启动着色器
</span><span style="color:#75715e"></span>    [self.effect prepareToDraw];
    glDrawElements(GL_TRIANGLES, self.count, GL_UNSIGNED_INT, <span style="color:#ae81ff">0</span>);
}
</code></pre></div><p>这样我们就可以看到最终的效果了：</p>
<!-- raw HTML omitted -->
<p>细心观察就会发现，我们想要的结果是一个正方形，现在出来的效果却是一个矩形，这是为什么呢？因为默认的，“Effect”的投影矩阵是一个单位矩阵，它不做任何变换，将场景（-1，-1，-1）到（1，1，1）的立文体范围的物体，投射到屏幕的X：-1，1，Y：-1，1。因此，当屏幕本身是非正方形时，正方形的物体将被拉伸，从而显示为矩形。所以我们要在<code>update</code> 中修改投影矩阵：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ObjectiveC" data-lang="ObjectiveC">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">update</span> {
 
    CGSize size <span style="color:#f92672">=</span> self.view.bounds.size;
    <span style="color:#66d9ef">float</span> aspect <span style="color:#f92672">=</span> fabs(size.width <span style="color:#f92672">/</span> size.height);
    
    GLKMatrix4 projectMartix <span style="color:#f92672">=</span>    GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span style="color:#ae81ff">130.0</span>), aspect, <span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">10.0</span>);
    <span style="color:#75715e">// 第一个参数代表视角
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第二个参数代表比例
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第三个参数代表近平面距离
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第四个参数代表远平面距离
</span><span style="color:#75715e"></span>    
    self.effect.transform.projectionMatrix <span style="color:#f92672">=</span> projectMartix;
    
    GLKMatrix4 modelMatrix <span style="color:#f92672">=</span>     GLKMatrix4Translate(GLKMatrix4Identity, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>); <span style="color:#75715e">// 修改 Z 轴的距离
</span><span style="color:#75715e"></span>    self.effect.transform.modelviewMatrix <span style="color:#f92672">=</span> modelMatrix;
}
</code></pre></div><p>最终通过这段代码就能得到我们想要的结果了：一个正方形（Demo 在<a href="https://github.com/cconecode/OpenGLESTutorials">这里</a>）。在学习过程中，踩了很多坑，包括一开始的图像显示不出来，API 的意思也不明确。后来通过 Google 查阅相关资料，把一些 bug 解决了，同时也加深了对 OpenGL ES 的理解，学习到了很多的东西。上面的知识，在代码中我已经注释的很清楚了，如果有不懂的地方或者不正确的地方，欢迎指正交流~</p><ul class="pa0">
  
   <li class="list">
     <a href="/tags/OpenGL-ES" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">OpenGL ES</a>
   </li>
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/post/opengles-1/">初识 OpenGL ES</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://superchun.net" >
    &copy; 2021 悉达多｜PainMaker
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
